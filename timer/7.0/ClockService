package com.krdonon.timer

import android.Manifest
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.IBinder
import android.os.SystemClock
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import kotlinx.coroutines.*
import java.util.Locale

/**
 * 타이머/스톱워치 진행 상황을 알림으로 보여주는 Foreground Service.
 * - leader 알림은 FOREGROUND_ID 하나만 사용(중복 방지)
 * - 나머지는 NID_* 사용
 * - 그룹(summary) 알림을 함께 게시해 순서 흔들림 방지
 * - 아무 것도 안 돌면 서비스 자동 종료
 */
class ClockService : Service() {

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

    // Timer state
    private var timerJob: Job? = null
    private var timerEndElapsed: Long = 0L  // SystemClock.elapsedRealtime() 기준

    // Stopwatch state
    private var stopwatchJob: Job? = null
    private var stopwatchBase: Long = 0L    // 경과: now - base

    // Foreground 관리
    private var isInForeground = false
    private var foregroundLeader: Leader? = null

    enum class Leader { TIMER, STOPWATCH }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_START_TIMER -> {
                val durationMs = intent.getLongExtra(EXTRA_DURATION_MS, 0L).coerceAtLeast(0L)
                startTimer(durationMs)
            }
            ACTION_STOP_TIMER -> stopTimer()
            ACTION_START_STOPWATCH -> {
                val base = intent.getLongExtra(EXTRA_STOPWATCH_BASE, 0L)
                startStopwatch(baseElapsed = base)
            }
            ACTION_STOP_STOPWATCH -> stopStopwatch()
            ACTION_STOP_ALL -> {
                stopTimer()
                stopStopwatch()
            }
        }
        return START_STICKY
    }

    override fun onDestroy() {
        timerJob?.cancel()
        stopwatchJob?.cancel()
        scope.cancel()
        super.onDestroy()
    }

    // ---------- 채널 ----------
    private fun ensureChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            nm.createNotificationChannel(
                NotificationChannel(
                    TIMER_CHANNEL, "타이머 진행", NotificationManager.IMPORTANCE_LOW
                ).apply {
                    description = "타이머 남은 시간을 표시합니다."
                    setSound(null, null)
                    enableVibration(false)
                    lockscreenVisibility = Notification.VISIBILITY_PUBLIC
                }
            )
            nm.createNotificationChannel(
                NotificationChannel(
                    STOPWATCH_CHANNEL, "스톱워치 진행", NotificationManager.IMPORTANCE_LOW
                ).apply {
                    description = "스톱워치 경과 시간을 표시합니다."
                    setSound(null, null)
                    enableVibration(false)
                    lockscreenVisibility = Notification.VISIBILITY_PUBLIC
                }
            )
        }
    }

    // region Timer

    private fun startTimer(durationMs: Long) {
        ensureChannels()
        postGroupSummary() // 그룹 요약 항상 게시

        val now = SystemClock.elapsedRealtime()
        timerEndElapsed = now + durationMs

        // Foreground 선점 (없으면 Timer로 올림)
        ensureForeground(Leader.TIMER)

        timerJob?.cancel()
        timerJob = scope.launch {
            var lastNotify = 0L
            while (isActive) {
                val remain = timerEndElapsed - SystemClock.elapsedRealtime()
                if (remain <= 0L) {
                    notifyTimer(0L)
                    delay(300)
                    cancelTimerNotification()
                    break
                } else {
                    val t = System.currentTimeMillis()
                    if (t - lastNotify >= 1000) {
                        notifyTimer(remain)
                        lastNotify = t
                    }
                }
                delay(100)
            }
            timerJob = null
            onChannelPossiblyIdle()
        }
    }

    private fun stopTimer() {
        timerJob?.cancel()
        timerJob = null
        cancelTimerNotification()
        onChannelPossiblyIdle()
    }

    // endregion

    // region Stopwatch

    private fun startStopwatch(baseElapsed: Long = 0L) {
        ensureChannels()
        postGroupSummary() // 그룹 요약 항상 게시

        val now = SystemClock.elapsedRealtime()
        stopwatchBase = now - baseElapsed

        // Foreground 선점 (없으면 Stopwatch로 올림)
        ensureForeground(Leader.STOPWATCH)

        stopwatchJob?.cancel()
        stopwatchJob = scope.launch {
            var lastNotify = 0L
            while (isActive) {
                val elapsed = SystemClock.elapsedRealtime() - stopwatchBase
                val t = System.currentTimeMillis()
                if (t - lastNotify >= 1000) {
                    notifyStopwatch(elapsed)
                    lastNotify = t
                }
                delay(100)
            }
        }
    }

    private fun stopStopwatch() {
        stopwatchJob?.cancel()
        stopwatchJob = null
        cancelStopwatchNotification()
        onChannelPossiblyIdle()
    }

    // endregion

    // region Foreground & notifications

    /**
     * 처음 포그라운드로 올릴 때도 '실제 값'으로 표시.
     * 그리고 leader 쪽은 FOREGROUND_ID 하나로만 업데이트(중복 방지).
     */
    private fun ensureForeground(preferred: Leader) {
        if (!isInForeground) {
            foregroundLeader = preferred
            val initial: Notification = when (preferred) {
                Leader.TIMER -> buildTimerNotification(
                    (timerEndElapsed - SystemClock.elapsedRealtime()).coerceAtLeast(0L)
                )
                Leader.STOPWATCH -> buildStopwatchNotification(
                    (SystemClock.elapsedRealtime() - stopwatchBase).coerceAtLeast(0L)
                )
            }
            runCatching { startForeground(FOREGROUND_ID, initial) }
            isInForeground = true
        }
    }

    private fun onChannelPossiblyIdle() {
        val timerRunning = timerJob != null
        val stopwatchRunning = stopwatchJob != null

        when {
            timerRunning && stopwatchRunning -> {
                if (foregroundLeader == null) foregroundLeader = Leader.TIMER
                postGroupSummary()
            }
            timerRunning -> {
                foregroundLeader = Leader.TIMER
                runCatching {
                    startForeground(
                        FOREGROUND_ID,
                        buildTimerNotification(
                            (timerEndElapsed - SystemClock.elapsedRealtime()).coerceAtLeast(0L)
                        )
                    )
                }
                postGroupSummary()
            }
            stopwatchRunning -> {
                foregroundLeader = Leader.STOPWATCH
                runCatching {
                    startForeground(
                        FOREGROUND_ID,
                        buildStopwatchNotification(
                            (SystemClock.elapsedRealtime() - stopwatchBase).coerceAtLeast(0L)
                        )
                    )
                }
                postGroupSummary()
            }
            else -> {
                cancelGroupSummary()
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                    stopForeground(STOP_FOREGROUND_REMOVE)
                } else {
                    @Suppress("DEPRECATION")
                    stopForeground(true)
                }
                isInForeground = false
                foregroundLeader = null
                stopSelf()
            }
        }
    }

    /** ====== 그룹 요약 알림 ====== */
    private fun postGroupSummary() {
        // 요약 알림은 한 번만, 조용히
        val n = NotificationCompat.Builder(this, STOPWATCH_CHANNEL)
            .setSmallIcon(R.drawable.ic_notification)
            .setOngoing(false)
            .setOnlyAlertOnce(true)
            .setSilent(true)
            .setShowWhen(false)
            .setGroup(GROUP_KEY_CLOCK)
            .setGroupSummary(true)
            .setPriority(NotificationCompat.PRIORITY_MIN)
            .build()
        notifySafe(NID_SUMMARY, n)
    }

    private fun cancelGroupSummary() {
        cancelSafe(NID_SUMMARY)
    }

    /** ====== 타이머 알림 업데이트/취소 (ID 선택 로직 포함) ====== */
    private fun notifyTimer(remainingMs: Long) {
        val id = if (foregroundLeader == Leader.TIMER) FOREGROUND_ID else NID_TIMER
        notifySafe(id, buildTimerNotification(remainingMs))
    }

    private fun cancelTimerNotification() {
        val id = if (foregroundLeader == Leader.TIMER) FOREGROUND_ID else NID_TIMER
        cancelSafe(id)
    }

    /** ====== 스톱워치 알림 업데이트/취소 (ID 선택 로직 포함) ====== */
    private fun notifyStopwatch(elapsedMs: Long) {
        val id = if (foregroundLeader == Leader.STOPWATCH) FOREGROUND_ID else NID_STOPWATCH
        notifySafe(id, buildStopwatchNotification(elapsedMs))
    }

    private fun cancelStopwatchNotification() {
        val id = if (foregroundLeader == Leader.STOPWATCH) FOREGROUND_ID else NID_STOPWATCH
        cancelSafe(id)
    }

    private fun buildTimerNotification(remainingMs: Long): Notification {
        val content = "남은 시간: ${formatHMSms4(remainingMs)}"
        return NotificationCompat.Builder(this, TIMER_CHANNEL)
            .setContentTitle("타이머")
            .setContentText(content)
            .setSmallIcon(R.drawable.ic_notification)
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .setSilent(true)
            .setShowWhen(false)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setGroup(GROUP_KEY_CLOCK)
            .setSortKey(TIMER_SORT_KEY) // 항상 아래쪽
            .setContentIntent(mainPendingIntent(ACTION_OPEN_TIMER))   // 타이머 탭 열기
            .build()
    }

    private fun buildStopwatchNotification(elapsedMs: Long): Notification {
        val content = "경과 시간: ${formatHMSms4(elapsedMs)}"
        return NotificationCompat.Builder(this, STOPWATCH_CHANNEL)
            .setContentTitle("스톱워치")
            .setContentText(content)
            .setSmallIcon(R.drawable.ic_notification)
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .setSilent(true)
            .setShowWhen(false)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setGroup(GROUP_KEY_CLOCK)
            .setSortKey(STOPWATCH_SORT_KEY) // 항상 위쪽
            .setContentIntent(mainPendingIntent(/* 기본 메인 진입 */ null))
            .build()
    }

    private fun mainPendingIntent(action: String?): PendingIntent {
        val open = Intent(this, com.krdonon.timer.MainActivity::class.java).apply {
            if (action != null) this.action = action
            // singleTop 액티비티로 전달 → 재생성/초기화 방지
            addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)
        }
        val flags = PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        return PendingIntent.getActivity(this, 0, open, flags)
    }

    // ✅ 4자리(만분의 1초 표기)로 포맷
    private fun formatHMSms4(msInput: Long): String {
        val ms = msInput.coerceAtLeast(0L)
        val totalSec = ms / 1000
        val h = totalSec / 3600
        val m = (totalSec % 3600) / 60
        val s = totalSec % 60
        val tenTh = ((ms % 1000) * 10).toInt()
        return String.format(Locale.getDefault(), "%02d:%02d:%02d:%04d", h, m, s, tenTh)
    }

    // --- 안전하게 notify/cancel ---
    private fun canPostNotifications(): Boolean {
        return if (Build.VERSION.SDK_INT >= 33) {
            ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED
        } else {
            true
        }
    }

    private fun notifySafe(id: Int, notification: Notification) {
        if (!canPostNotifications()) return
        try {
            NotificationManagerCompat.from(this).notify(id, notification)
        } catch (_: SecurityException) { }
    }

    private fun cancelSafe(id: Int) {
        try {
            NotificationManagerCompat.from(this).cancel(id)
        } catch (_: SecurityException) { }
    }

    // endregion

    companion object {
        // 알림에서 타이머 탭으로 이동
        private const val ACTION_OPEN_TIMER = "com.krdonon.timer.action.OPEN_TIMER"

        private const val ACTION_START_TIMER = "com.krdonon.timer.action.START_TIMER"
        private const val ACTION_STOP_TIMER = "com.krdonon.timer.action.STOP_TIMER"
        private const val ACTION_START_STOPWATCH = "com.krdonon.timer.action.START_STOPWATCH"
        private const val ACTION_STOP_STOPWATCH = "com.krdonon.timer.action.STOP_STOPWATCH"
        private const val ACTION_STOP_ALL = "com.krdonon.timer.action.STOP_ALL"

        private const val EXTRA_DURATION_MS = "duration_ms"
        private const val EXTRA_STOPWATCH_BASE = "stopwatch_base"

        private const val FOREGROUND_ID = 42
        private const val NID_SUMMARY = 1000
        private const val NID_TIMER = 1001
        private const val NID_STOPWATCH = 1002

        private const val TIMER_CHANNEL = "timer_channel"
        private const val STOPWATCH_CHANNEL = "stopwatch_channel"

        // 그룹/정렬 고정
        private const val GROUP_KEY_CLOCK = "com.krdonon.timer.clock_group"
        private const val STOPWATCH_SORT_KEY = "00" // 항상 위
        private const val TIMER_SORT_KEY = "10"     // 항상 아래

        // ---- 외부에서 쉽게 호출할 수 있는 헬퍼들 ----
        fun startTimer(context: Context, durationMs: Long) {
            val i = Intent(context, ClockService::class.java).apply {
                action = ACTION_START_TIMER
                putExtra(EXTRA_DURATION_MS, durationMs)
            }
            ContextCompat.startForegroundService(context, i)
        }

        fun stopTimer(context: Context) {
            val i = Intent(context, ClockService::class.java).apply { action = ACTION_STOP_TIMER }
            context.startService(i)
        }

        fun startStopwatch(context: Context, baseElapsed: Long = 0L) {
            val i = Intent(context, ClockService::class.java).apply {
                action = ACTION_START_STOPWATCH
                putExtra(EXTRA_STOPWATCH_BASE, baseElapsed)
            }
            ContextCompat.startForegroundService(context, i)
        }

        fun stopStopwatch(context: Context) {
            val i = Intent(context, ClockService::class.java).apply { action = ACTION_STOP_STOPWATCH }
            context.startService(i)
        }

        fun stopAll(context: Context) {
            val i = Intent(context, ClockService::class.java).apply { action = ACTION_STOP_ALL }
            context.startService(i)
        }
    }
}
