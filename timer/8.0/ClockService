package com.krdonon.timer

import android.Manifest
import android.annotation.SuppressLint
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.IBinder
import android.os.SystemClock
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import kotlinx.coroutines.*
import java.util.Locale

/**
 * 메인 타이머/스톱워치 + 보조(여러 개) 타이머를 알림으로 표시하는 ForegroundService.
 * - leader(메인/스톱워치) 알림은 FOREGROUND_ID(42) 하나
 * - 보조 타이머는 각각 고유 notifyId 를 사용
 */
class ClockService : Service() {

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

    // 메인
    private var timerJob: Job? = null
    private var timerEndElapsed: Long = 0L

    // 스톱워치
    private var stopwatchJob: Job? = null
    private var stopwatchBase: Long = 0L

    // 보조 타이머들(id -> Job)
    private val extraJobs = mutableMapOf<String, Job>()

    // FG 상태
    private var isInForeground = false
    private var foregroundLeader: Leader? = null

    enum class Leader { TIMER, STOPWATCH }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_START_TIMER -> {
                val durationMs = intent.getLongExtra(EXTRA_DURATION_MS, 0L).coerceAtLeast(0L)
                startTimer(durationMs)
            }
            ACTION_STOP_TIMER -> stopTimer()

            ACTION_START_STOPWATCH -> {
                val base = intent.getLongExtra(EXTRA_STOPWATCH_BASE, 0L)
                startStopwatch(baseElapsed = base)
            }
            ACTION_STOP_STOPWATCH -> stopStopwatch()

            ACTION_START_EXTRA -> {
                val id = intent.getStringExtra(EXTRA_ID) ?: return START_STICKY
                val label = intent.getStringExtra(EXTRA_LABEL) ?: "타이머"
                val ms = intent.getLongExtra(EXTRA_DURATION_MS, 0L).coerceAtLeast(0L)
                startExtra(id, label, ms)
            }
            ACTION_STOP_EXTRA -> {
                val id = intent.getStringExtra(EXTRA_ID) ?: return START_STICKY
                stopExtra(id)
            }

            ACTION_STOP_ALL -> {
                stopTimer(); stopStopwatch(); stopAllExtras()
            }
        }
        return START_STICKY
    }

    override fun onDestroy() {
        timerJob?.cancel()
        stopwatchJob?.cancel()
        stopAllExtras()
        scope.cancel()
        super.onDestroy()
    }

    // ---------- 채널 ----------
    private fun ensureChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            fun ch(id: String, name: String) = NotificationChannel(
                id, name, NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = name
                setSound(null, null)
                enableVibration(false)
                lockscreenVisibility = Notification.VISIBILITY_PUBLIC
            }
            nm.createNotificationChannel(ch(TIMER_CHANNEL, "타이머 진행"))
            nm.createNotificationChannel(ch(STOPWATCH_CHANNEL, "스톱워치 진행"))
            nm.createNotificationChannel(ch(EXTRA_CHANNEL, "보조 타이머 진행"))
        }
    }

    // ===================== Timer =====================
    private fun startTimer(durationMs: Long) {
        ensureChannels()
        timerEndElapsed = SystemClock.elapsedRealtime() + durationMs
        ensureForeground(Leader.TIMER)

        timerJob?.cancel()
        timerJob = scope.launch {
            var last = 0L
            while (isActive) {
                val remain = timerEndElapsed - SystemClock.elapsedRealtime()
                if (remain <= 0L) {
                    notifyTimer(0L); delay(300); cancelTimerNotification(); break
                } else {
                    val t = System.currentTimeMillis()
                    if (t - last >= 1000) { notifyTimer(remain); last = t }
                }
                delay(100)
            }
            timerJob = null
            onChannelPossiblyIdle()
        }
    }

    private fun stopTimer() {
        timerJob?.cancel()
        timerJob = null
        cancelTimerNotification()
        onChannelPossiblyIdle()
    }

    // ===================== Stopwatch =====================
    private fun startStopwatch(baseElapsed: Long = 0L) {
        ensureChannels()
        stopwatchBase = SystemClock.elapsedRealtime() - baseElapsed
        ensureForeground(Leader.STOPWATCH)

        stopwatchJob?.cancel()
        stopwatchJob = scope.launch {
            var last = 0L
            while (isActive) {
                val elapsed = SystemClock.elapsedRealtime() - stopwatchBase
                val t = System.currentTimeMillis()
                if (t - last >= 1000) { notifyStopwatch(elapsed); last = t }
                delay(100)
            }
        }
    }

    private fun stopStopwatch() {
        stopwatchJob?.cancel()
        stopwatchJob = null
        cancelStopwatchNotification()
        onChannelPossiblyIdle()
    }

    // ===================== Extras =====================
    private fun startExtra(id: String, label: String, durationMs: Long) {
        ensureChannels()
        // 중복 방지
        extraJobs[id]?.cancel()

        val endElapsed = SystemClock.elapsedRealtime() + durationMs
        val notifyId = extraNotifyId(id)

        extraJobs[id] = scope.launch {
            var last = 0L
            while (isActive) {
                val remain = endElapsed - SystemClock.elapsedRealtime()
                if (remain <= 0L) {
                    notifySafe(notifyId, buildExtraNotification(label, 0L))
                    delay(300)
                    cancelSafe(notifyId)
                    break
                } else {
                    val t = System.currentTimeMillis()
                    if (t - last >= 1000) {
                        notifySafe(notifyId, buildExtraNotification(label, remain))
                        last = t
                    }
                }
                delay(100)
            }
            extraJobs.remove(id)
            onChannelPossiblyIdle()
        }
    }

    private fun stopExtra(id: String) {
        extraJobs.remove(id)?.cancel()
        cancelSafe(extraNotifyId(id))
        onChannelPossiblyIdle()
    }

    private fun stopAllExtras() {
        extraJobs.values.forEach { it.cancel() }
        extraJobs.clear()
        // 보조 알림들은 전부 지움(간단히 10000~10100 범위 사용)
        for (i in 0 until 100) cancelSafe(EXTRA_BASE_NID + i)
    }

    private fun extraNotifyId(id: String): Int =
        EXTRA_BASE_NID + (id.hashCode() and 0x7fffffff) % 100

    // ===================== Foreground =====================
    private fun ensureForeground(preferred: Leader) {
        if (!isInForeground) {
            foregroundLeader = preferred
            val initial: Notification = when (preferred) {
                Leader.TIMER -> buildTimerNotification(0L)
                Leader.STOPWATCH -> buildStopwatchNotification(0L)
            }
            runCatching { startForeground(FOREGROUND_ID, initial) }
            isInForeground = true
        }
    }

    private fun onChannelPossiblyIdle() {
        val timerRunning = timerJob != null
        val stopwatchRunning = stopwatchJob != null
        val extraRunning = extraJobs.isNotEmpty()

        when {
            timerRunning -> {
                foregroundLeader = Leader.TIMER
                runCatching {
                    startForeground(
                        FOREGROUND_ID,
                        buildTimerNotification(
                            (timerEndElapsed - SystemClock.elapsedRealtime()).coerceAtLeast(0L)
                        )
                    )
                }
            }
            stopwatchRunning -> {
                foregroundLeader = Leader.STOPWATCH
                runCatching {
                    startForeground(
                        FOREGROUND_ID,
                        buildStopwatchNotification(
                            (SystemClock.elapsedRealtime() - stopwatchBase).coerceAtLeast(0L)
                        )
                    )
                }
            }
            else -> {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                    // N+ 에서는 상수 명시
                    stopForeground(Service.STOP_FOREGROUND_REMOVE)
                } else {
                    @Suppress("DEPRECATION")
                    stopForeground(true)
                }
                isInForeground = false
                foregroundLeader = null
                if (!extraRunning) stopSelf()
            }
        }
    }

    // ===================== Notifications =====================
    private fun notifyTimer(remainingMs: Long) {
        val id = if (foregroundLeader == Leader.TIMER) FOREGROUND_ID else NID_TIMER
        notifySafe(id, buildTimerNotification(remainingMs))
    }

    private fun cancelTimerNotification() {
        val id = if (foregroundLeader == Leader.TIMER) FOREGROUND_ID else NID_TIMER
        cancelSafe(id)
    }

    private fun notifyStopwatch(elapsedMs: Long) {
        val id = if (foregroundLeader == Leader.STOPWATCH) FOREGROUND_ID else NID_STOPWATCH
        notifySafe(id, buildStopwatchNotification(elapsedMs))
    }

    private fun cancelStopwatchNotification() {
        val id = if (foregroundLeader == Leader.STOPWATCH) FOREGROUND_ID else NID_STOPWATCH
        cancelSafe(id)
    }

    private fun buildTimerNotification(remainingMs: Long): Notification {
        val content = "남은 시간: ${formatHMSms4(remainingMs)}"
        return NotificationCompat.Builder(this, TIMER_CHANNEL)
            .setContentTitle("타이머")
            .setContentText(content)
            .setSmallIcon(R.drawable.ic_notification)
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .setShowWhen(false)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setContentIntent(mainPendingIntent(null))
            .build()
    }

    private fun buildStopwatchNotification(elapsedMs: Long): Notification {
        val content = "경과 시간: ${formatHMSms4(elapsedMs)}"
        return NotificationCompat.Builder(this, STOPWATCH_CHANNEL)
            .setContentTitle("스톱워치")
            .setContentText(content)
            .setSmallIcon(R.drawable.ic_notification)
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .setShowWhen(false)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setContentIntent(mainPendingIntent(null))
            .build()
    }

    private fun buildExtraNotification(label: String, remainingMs: Long): Notification {
        val content = "${formatHMSms4(remainingMs)} 남음"
        return NotificationCompat.Builder(this, EXTRA_CHANNEL)
            .setContentTitle(label)
            .setContentText(content)
            .setSmallIcon(R.drawable.ic_notification)
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .setShowWhen(false)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setContentIntent(mainPendingIntent(null))
            .build()
    }

    private fun mainPendingIntent(action: String?): PendingIntent {
        val open = Intent(this, com.krdonon.timer.MainActivity::class.java).apply {
            if (action != null) this.action = action
            addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)
        }
        val flags = PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        return PendingIntent.getActivity(this, 0, open, flags)
    }

    private fun formatHMSms4(msInput: Long): String {
        val ms = msInput.coerceAtLeast(0L)
        val totalSec = ms / 1000
        val h = totalSec / 3600
        val m = (totalSec % 3600) / 60
        val s = totalSec % 60
        val tenTh = ((ms % 1000) * 10).toInt()
        return String.format(Locale.getDefault(), "%02d:%02d:%02d:%04d", h, m, s, tenTh)
    }

    private fun canPostNotifications(): Boolean {
        return if (Build.VERSION.SDK_INT >= 33) {
            ActivityCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) ==
                    PackageManager.PERMISSION_GRANTED
        } else true
    }

    @SuppressLint("MissingPermission")
    private fun notifySafe(id: Int, notification: Notification) {
        if (!canPostNotifications()) return
        runCatching { NotificationManagerCompat.from(this).notify(id, notification) }
    }

    private fun cancelSafe(id: Int) {
        runCatching { NotificationManagerCompat.from(this).cancel(id) }
    }

    companion object {
        // actions
        private const val ACTION_START_TIMER = "com.krdonon.timer.action.START_TIMER"
        private const val ACTION_STOP_TIMER = "com.krdonon.timer.action.STOP_TIMER"
        private const val ACTION_START_STOPWATCH = "com.krdonon.timer.action.START_STOPWATCH"
        private const val ACTION_STOP_STOPWATCH = "com.krdonon.timer.action.STOP_STOPWATCH"
        private const val ACTION_START_EXTRA = "com.krdonon.timer.action.START_EXTRA"
        private const val ACTION_STOP_EXTRA = "com.krdonon.timer.action.STOP_EXTRA"
        private const val ACTION_STOP_ALL = "com.krdonon.timer.action.STOP_ALL"

        // extras
        private const val EXTRA_DURATION_MS = "duration_ms"
        private const val EXTRA_STOPWATCH_BASE = "stopwatch_base"
        private const val EXTRA_ID = "id"
        private const val EXTRA_LABEL = "label"

        // ids
        private const val FOREGROUND_ID = 42
        private const val NID_TIMER = 1001
        private const val NID_STOPWATCH = 1002
        private const val EXTRA_BASE_NID = 2000

        // channels
        private const val TIMER_CHANNEL = "timer_channel"
        private const val STOPWATCH_CHANNEL = "stopwatch_channel"
        private const val EXTRA_CHANNEL = "extra_timer_channel"

        // helpers
        fun startTimer(context: Context, durationMs: Long) {
            val i = Intent(context, ClockService::class.java).apply {
                action = ACTION_START_TIMER
                putExtra(EXTRA_DURATION_MS, durationMs)
            }
            ContextCompat.startForegroundService(context, i)
        }

        fun stopTimer(context: Context) {
            val i = Intent(context, ClockService::class.java).apply { action = ACTION_STOP_TIMER }
            context.startService(i)
        }

        fun startStopwatch(context: Context, baseElapsed: Long = 0L) {
            val i = Intent(context, ClockService::class.java).apply {
                action = ACTION_START_STOPWATCH
                putExtra(EXTRA_STOPWATCH_BASE, baseElapsed)
            }
            ContextCompat.startForegroundService(context, i)
        }

        fun stopStopwatch(context: Context) {
            val i = Intent(context, ClockService::class.java).apply { action = ACTION_STOP_STOPWATCH }
            context.startService(i)
        }

        // ★ 보조 타이머 헬퍼
        fun startExtraTimer(context: Context, id: String, label: String, durationMs: Long) {
            val i = Intent(context, ClockService::class.java).apply {
                action = ACTION_START_EXTRA
                putExtra(EXTRA_ID, id)
                putExtra(EXTRA_LABEL, label)
                putExtra(EXTRA_DURATION_MS, durationMs)
            }
            ContextCompat.startForegroundService(context, i)
        }

        fun stopExtraTimer(context: Context, id: String) {
            val i = Intent(context, ClockService::class.java).apply {
                action = ACTION_STOP_EXTRA
                putExtra(EXTRA_ID, id)
            }
            context.startService(i)
        }

        fun stopAll(context: Context) {
            val i = Intent(context, ClockService::class.java).apply { action = ACTION_STOP_ALL }
            context.startService(i)
        }
    }
}
