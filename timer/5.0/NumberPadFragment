package com.krdonon.timer

import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.text.SpannableString
import android.text.Spanned
import android.text.method.LinkMovementMethod
import android.text.style.ClickableSpan
import android.text.style.StyleSpan
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.fragment.app.Fragment
import java.util.Calendar
import java.util.Locale
import java.util.concurrent.TimeUnit
import kotlin.math.max
import kotlin.math.min

class NumberPadFragment : Fragment() {

    private lateinit var inputTimeText: TextView
    private lateinit var nowOnPadText: TextView
    private lateinit var btnTomorrow: Button
    private lateinit var btnAmPm: Button

    private lateinit var lblH: TextView
    private lateinit var lblM: TextView
    private lateinit var lblS: TextView
    private lateinit var lblMS: TextView

    // 0=시, 1=분, 2=초, 3=천분(4자리)
    private var selected = 1 // 기본: '분'부터 선택
    private val lens = intArrayOf(2, 2, 2, 4)
    private val digits = arrayOf(
        CharArray(2) { '0' }, // 시
        CharArray(2) { '0' }, // 분
        CharArray(2) { '0' }, // 초
        CharArray(4) { '0' }  // 천분
    )
    private val cursors = intArrayOf(0, 0, 0, 0)

    private var isTomorrow = false
    private var isAm = true
    private var ampmSelected = false  // ✅ 오전/오후 버튼이 눌렸는지 여부 저장

    private val handler = Handler(Looper.getMainLooper())
    private var ticker: Runnable? = null

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val v = inflater.inflate(R.layout.number_pad, container, false)

        inputTimeText = v.findViewById(R.id.inputTimeText)
        nowOnPadText   = v.findViewById(R.id.nowOnPadText)
        btnTomorrow    = v.findViewById(R.id.btnTomorrow)
        btnAmPm        = v.findViewById(R.id.btnAmPm)

        lblH  = v.findViewById(R.id.lblH)
        lblM  = v.findViewById(R.id.lblM)
        lblS  = v.findViewById(R.id.lblS)
        lblMS = v.findViewById(R.id.lblMS)

        // 라벨 클릭 → 선택
        lblH.setOnClickListener { select(0) }
        lblM.setOnClickListener { select(1) }
        lblS.setOnClickListener { select(2) }
        lblMS.setOnClickListener { select(3) }

        // "내일" 토글
        btnTomorrow.setOnClickListener {
            isTomorrow = !isTomorrow
            btnTomorrow.text = if (isTomorrow) getString(R.string.label_tomorrow_checked)
            else getString(R.string.label_tomorrow)
        }

        // "오전/오후" 토글
        btnAmPm.setOnClickListener {
            ampmSelected = true   // ✅ 버튼 눌림 기록
            isAm = !isAm
            btnAmPm.text = if (isAm) getString(R.string.label_am) else getString(R.string.label_pm)
        }

        // 숫자 버튼
        val ids = listOf(
            R.id.btn0, R.id.btn1, R.id.btn2, R.id.btn3, R.id.btn4,
            R.id.btn5, R.id.btn6, R.id.btn7, R.id.btn8, R.id.btn9
        )
        for (id in ids) {
            v.findViewById<Button>(id).setOnClickListener { b ->
                val d = (b as Button).text.first()
                putDigit(d)
            }
        }

        // 지우기/다음
        v.findViewById<Button>(R.id.btnDelete).setOnClickListener { clearCurrentBlock() }
        v.findViewById<Button>(R.id.btnNext).setOnClickListener { finishAndReturn() }

        // 키패드 상단 현재 시각 100ms 갱신
        ticker = object : Runnable {
            override fun run() {
                updateNowOnPad()
                handler.postDelayed(this, 100L)
            }
        }
        handler.post(ticker!!)

        refreshPreview()
        select(selected)
        return v
    }

    /** 블록 선택(라벨 굵게 표시) */
    private fun select(idx: Int) {
        selected = idx
        fun setBold(tv: TextView, bold: Boolean) {
            val s = SpannableString(tv.text)
            s.setSpan(
                StyleSpan(if (bold) android.graphics.Typeface.BOLD else android.graphics.Typeface.NORMAL),
                0, s.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
            )
            tv.text = s
        }
        setBold(lblH, idx == 0)
        setBold(lblM, idx == 1)
        setBold(lblS, idx == 2)
        setBold(lblMS, idx == 3)
    }

    /** 숫자 입력 */
    private fun putDigit(ch: Char) {
        val len = lens[selected]
        val cur = cursors[selected]
        digits[selected][cur] = ch
        cursors[selected] = min(cur + 1, len - 1)
        refreshPreview()
    }

    /** 블록 초기화 */
    private fun clearCurrentBlock() {
        for (i in digits[selected].indices) digits[selected][i] = '0'
        cursors[selected] = 0
        refreshPreview()
    }

    /** 미리보기 */
    private fun refreshPreview() {
        val hh  = String(digits[0]).toInt().coerceIn(0, 23)
        val mm  = String(digits[1]).toInt().coerceIn(0, 59)
        val ss  = String(digits[2]).toInt().coerceIn(0, 59)
        val mmm = String(digits[3]).toInt().coerceIn(0, 9999)

        val text = String.format(Locale.getDefault(), "%02d:%02d:%02d:%04d", hh, mm, ss, mmm)
        val sp = SpannableString(text)

        fun span(start: Int, end: Int, idx: Int) {
            sp.setSpan(object : ClickableSpan() {
                override fun onClick(widget: View) { select(idx) }
                override fun updateDrawState(ds: android.text.TextPaint) {
                    ds.isUnderlineText = false
                    ds.isFakeBoldText = (selected == idx)
                }
            }, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        }
        span(0, 2, 0)   // HH
        span(3, 5, 1)   // MM
        span(6, 8, 2)   // SS
        span(9, 13, 3)  // MMMM

        inputTimeText.text = sp
        inputTimeText.movementMethod = LinkMovementMethod.getInstance()
        inputTimeText.highlightColor = 0x00000000
    }

    /** 상단 현재 시간 */
    private fun updateNowOnPad() {
        val now = Calendar.getInstance()
        val ampm = if (now.get(Calendar.AM_PM) == Calendar.AM)
            getString(R.string.label_am) else getString(R.string.label_pm)
        val h   = now.get(Calendar.HOUR)
        val m   = now.get(Calendar.MINUTE)
        val s   = now.get(Calendar.SECOND)
        val ms4 = now.get(Calendar.MILLISECOND) * 10
        nowOnPadText.text = getString(R.string.now_time_format, h, m, s, ms4, ampm)
    }

    /** 입력 완료 → TimerFragment로 전달 */
    private fun finishAndReturn() {
        var h   = String(digits[0]).toInt().coerceIn(0, 23)
        val m   = String(digits[1]).toInt().coerceIn(0, 59)
        val s   = String(digits[2]).toInt().coerceIn(0, 59)
        val ms4 = String(digits[3]).toInt().coerceIn(0, 9999)

        // 오전/오후 보정
        if (h in 1..11 && !isAm) h += 12
        if (h == 12 && isAm) h = 0
        if (h == 12 && !isAm) h = 12

        val bundle = Bundle()
        val now = Calendar.getInstance()

        if (isTomorrow) {
            // 내일 절대 시각
            val target = Calendar.getInstance().apply {
                add(Calendar.DAY_OF_YEAR, 1)
                set(Calendar.HOUR_OF_DAY, h)
                set(Calendar.MINUTE, m)
                set(Calendar.SECOND, s)
                set(Calendar.MILLISECOND, ms4 / 10)
            }
            bundle.putLong("targetAt", target.timeInMillis)

        } else if (ampmSelected) {
            // ✅ 오전/오후 버튼 눌렸을 경우 → 절대 시각 계산
            val target = Calendar.getInstance().apply {
                set(Calendar.HOUR_OF_DAY, h)
                set(Calendar.MINUTE, m)
                set(Calendar.SECOND, s)
                set(Calendar.MILLISECOND, ms4 / 10)
            }
            if (target.before(now)) {
                target.add(Calendar.DAY_OF_YEAR, 1) // 이미 지난 시간이면 내일로
            }
            val duration = target.timeInMillis - now.timeInMillis
            bundle.putLong("duration", duration)

        } else {
            // 기본: 상대 타이머 (10초, 7초 등)
            val duration =
                TimeUnit.HOURS.toMillis(h.toLong()) +
                        TimeUnit.MINUTES.toMillis(m.toLong()) +
                        TimeUnit.SECONDS.toMillis(s.toLong()) +
                        ms4.toLong()
            bundle.putLong("duration", max(0L, duration))
        }

        parentFragmentManager.setFragmentResult("numberPadResult", bundle)
        parentFragmentManager.popBackStack()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        ticker?.let { handler.removeCallbacks(it) }
    }
}
