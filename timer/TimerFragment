package com.krdonon.timer

import android.app.AlarmManager
import android.app.KeyguardManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.os.CountDownTimer
import android.os.Handler
import android.os.Looper
import android.text.InputType
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.EditText
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.fragment.app.commit
import androidx.lifecycle.ViewModelProvider
import com.krdonon.timer.alarm.AlarmReceiver
import com.krdonon.timer.alarm.AlarmService
import java.util.Calendar
import java.util.Locale
import java.util.concurrent.TimeUnit

class TimerFragment : Fragment() {

    private lateinit var timerText: TextView
    private lateinit var currentTimeText: TextView
    private lateinit var nextTimeText: TextView
    private lateinit var btnStart: Button
    private lateinit var btnReset: Button
    private lateinit var btnAdd: Button
    private lateinit var btn10: Button
    private lateinit var btn15: Button
    private lateinit var btn30: Button
    private lateinit var extraTimersContainer: LinearLayout

    private val handler = Handler(Looper.getMainLooper())
    private var ticker: Runnable? = null

    private var timeLeftInMillis: Long = 0L
    private var mainTimer: CountDownTimer? = null
    private var running = false

    private lateinit var viewModel: TimerViewModel

    // ===== AlarmManager ì˜ˆì•½ ê´€ë ¨ =====
    private val alarmRequestCode = 10011
    private fun alarmPendingIntent(label: String = "ë©”ì¸ íƒ€ì´ë¨¸"): PendingIntent {
        val intent = Intent(requireContext(), AlarmReceiver::class.java).apply {
            putExtra(AlarmService.EXTRA_LABEL, label)
        }
        return PendingIntent.getBroadcast(
            requireContext(),
            alarmRequestCode,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
    }

    private fun scheduleExactAlarm(triggerAtMillis: Long, label: String = "ë©”ì¸ íƒ€ì´ë¨¸") {
        val am = requireContext().getSystemService(Context.ALARM_SERVICE) as AlarmManager
        val pi = alarmPendingIntent(label)
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                if (am.canScheduleExactAlarms()) {
                    am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAtMillis, pi)
                } else {
                    am.set(AlarmManager.RTC_WAKEUP, triggerAtMillis, pi)
                }
            } else {
                am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAtMillis, pi)
            }
        } catch (_: SecurityException) {
            am.set(AlarmManager.RTC_WAKEUP, triggerAtMillis, pi)
        }
    }

    private fun cancelExactAlarm() {
        val am = requireContext().getSystemService(Context.ALARM_SERVICE) as AlarmManager
        am.cancel(alarmPendingIntent())
    }
    // ================================

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val v = inflater.inflate(R.layout.fragment_timer, container, false)

        viewModel = ViewModelProvider(requireActivity())[TimerViewModel::class.java]

        timerText = v.findViewById(R.id.timerText)
        currentTimeText = v.findViewById(R.id.currentTimeText)
        nextTimeText = v.findViewById(R.id.nextTimeText)
        btnStart = v.findViewById(R.id.btnStartTimer)
        btnReset = v.findViewById(R.id.btnResetTimer)
        btnAdd   = v.findViewById(R.id.btnAddTimer)

        btn10 = v.findViewById(R.id.btnPreset10)
        btn15 = v.findViewById(R.id.btnPreset15)
        btn30 = v.findViewById(R.id.btnPreset30)
        extraTimersContainer = v.findViewById(R.id.extraTimersContainer)

        parentFragmentManager.setFragmentResultListener("numberPadResult", viewLifecycleOwner) { _, bundle ->
            val targetAt = bundle.getLong("targetAt", -1L)
            val dur = bundle.getLong("duration", -1L)
            when {
                targetAt > 0L -> setTargetAt(targetAt)
                dur >= 0L     -> setTargetTime(dur)
            }
        }

        ticker = object : Runnable {
            override fun run() {
                updateNow()
                handler.postDelayed(this, 100L)
            }
        }
        handler.post(ticker!!)

        val goInput: (View) -> Unit = {
            parentFragmentManager.commit {
                replace(R.id.fragment_container, NumberPadFragment())
                addToBackStack(null)
            }
        }
        timerText.setOnClickListener(goInput)
        nextTimeText.setOnClickListener(goInput)

        btn10.setOnClickListener { setDurationAndPreview(TimeUnit.MINUTES.toMillis(10)) }
        btn15.setOnClickListener { setDurationAndPreview(TimeUnit.MINUTES.toMillis(15)) }
        btn30.setOnClickListener { setDurationAndPreview(TimeUnit.MINUTES.toMillis(30)) }

        btnStart.setOnClickListener { if (running) pauseMain() else startMain() }
        btnReset.setOnClickListener { resetMain() }
        btnAdd.setOnClickListener   { addNewBlock(timeLeftInMillis) }

        restoreBlockTimersUI()

        timerText.text = formatDuration4(0L)
        nextTimeText.text = getString(R.string.next_time_prefix, formatDuration4(0L))
        btnStart.text = getString(R.string.btn_start)

        return v
    }

    /** ðŸ”• ìž ê¸ˆ í•´ì œ í›„ 'íƒ€ì´ë¨¸ í™”ë©´ìœ¼ë¡œ ëŒì•„ì™”ì„ ë•Œë§Œ' ìžë™ ì •ì§€ */
    override fun onResume() {
        super.onResume()

        val prefs = requireContext().getSharedPreferences(AlarmService.PREFS, Context.MODE_PRIVATE)
        val isRinging = prefs.getBoolean(AlarmService.KEY_RINGING, false)
        val startedFromKeyguard = prefs.getBoolean(AlarmService.KEY_STARTED_FROM_KEYGUARD, false)

        val km = requireContext().getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager
        val nowLocked = km.isKeyguardLocked

        // ì¡°ê±´:
        // 1) ì§€ê¸ˆ ìš¸ë¦¬ëŠ” ì¤‘ì´ì–´ì•¼ í•˜ê³ 
        // 2) ì•ŒëžŒì´ 'ìž ê¸ˆ ìƒíƒœì—ì„œ' ì‹œìž‘ëì–´ì•¼ í•˜ë©°
        // 3) ì§€ê¸ˆì€ ë” ì´ìƒ ìž ê¸ˆì´ ì•„ë‹ˆì–´ì•¼(=í•´ì œ í›„ í™”ë©´ìœ¼ë¡œ ëŒì•„ì˜¨ ìƒí™©)
        if (isRinging && startedFromKeyguard && !nowLocked) {
            AlarmService.stop(requireContext())
        }
    }

    /** -------- ë³´ì¡° íƒ€ì´ë¨¸ -------- */
    private fun restoreBlockTimersUI() {
        extraTimersContainer.removeAllViews()
        viewModel.blocks.forEach { state ->
            addBlockTimerViewFromState(state)
        }
    }

    private fun addNewBlock(initialMillis: Long) {
        if (initialMillis <= 0L) return
        val state = BlockTimerState(label = "íƒ€ì´ë¨¸", timeLeft = initialMillis, running = false)
        viewModel.blocks.add(state)
        addBlockTimerViewFromState(state)
    }

    private fun addBlockTimerViewFromState(state: BlockTimerState) {
        val blockView = layoutInflater.inflate(R.layout.timer_block, extraTimersContainer, false)

        val labelView = blockView.findViewById<TextView>(R.id.blockLabel)
        val tv       = blockView.findViewById<TextView>(R.id.blockTimerText)
        val btnStart = blockView.findViewById<Button>(R.id.blockStartBtn)
        val btnDel   = blockView.findViewById<Button>(R.id.blockDeleteBtn)

        labelView.text = state.label
        tv.text = formatDuration4(state.timeLeft)
        val block = BlockTimer(tv, btnStart, btnDel, labelView, state)

        tv.setOnClickListener { setTargetTime(state.timeLeft) }

        labelView.setOnClickListener { showRenameDialog(labelView) { newLabel ->
            state.label = newLabel
        } }

        extraTimersContainer.addView(blockView)

        if (state.running) block.start()
    }

    inner class BlockTimer(
        private val tv: TextView,
        private val startBtn: Button,
        deleteBtn: Button,
        private val labelView: TextView,
        private val state: BlockTimerState
    ) {
        private var cd: CountDownTimer? = null

        init {
            startBtn.setOnClickListener { if (state.running) pause() else start() }
            deleteBtn.setOnClickListener {
                cancel()
                viewModel.blocks.remove(state)
                extraTimersContainer.removeView(tv.parent as View)
            }
            updateUi()
        }

        private fun updateUi() {
            tv.text = formatDuration4(state.timeLeft)
            startBtn.text = if (state.running) getString(R.string.btn_pause) else getString(R.string.btn_start)
            labelView.text = state.label
        }

        fun start() {
            if (state.timeLeft <= 0L) return
            cd?.cancel()
            cd = object : CountDownTimer(state.timeLeft, 10L) {
                override fun onTick(ms: Long) {
                    state.timeLeft = ms
                    tv.text = formatDuration4(state.timeLeft)
                }
                override fun onFinish() {
                    state.timeLeft = 0L
                    state.running = false
                    updateUi()
                    AlarmService.start(requireContext(), state.label)
                }
            }.start()
            state.running = true
            updateUi()
        }

        fun pause() {
            cd?.cancel()
            state.running = false
            updateUi()
        }

        fun cancel() {
            cd?.cancel()
            state.running = false
        }
    }

    /** -------- ë©”ì¸ íƒ€ì´ë¨¸ -------- */
    private fun setTargetAt(targetAtMillis: Long) {
        timeLeftInMillis = (targetAtMillis - System.currentTimeMillis()).coerceAtLeast(0L)
        updateMainTimerUI()
    }

    private fun setTargetTime(durationMillis: Long) {
        timeLeftInMillis = durationMillis.coerceAtLeast(0L)
        updateMainTimerUI()
    }

    private fun setDurationAndPreview(durationMillis: Long) {
        timeLeftInMillis = durationMillis.coerceAtLeast(0L)
        updateMainTimerUI()
    }

    private fun startMain() {
        if (timeLeftInMillis <= 0L) return

        mainTimer?.cancel()
        val triggerAt = System.currentTimeMillis() + timeLeftInMillis

        // UI í‘œì‹œìš© ì¹´ìš´íŠ¸ë‹¤ìš´
        mainTimer = object : CountDownTimer(timeLeftInMillis, 10L) {
            override fun onTick(ms: Long) {
                timeLeftInMillis = ms
                updateMainTimerUI()
            }
            override fun onFinish() {
                running = false
                btnStart.text = getString(R.string.btn_start)
                timerText.text = formatDuration4(0L)
                nextTimeText.text = getString(R.string.next_time_prefix, formatDuration4(0L))
                cancelExactAlarm() // ì˜ˆì•½ ì œê±°
                AlarmService.start(requireContext(), "ë©”ì¸ íƒ€ì´ë¨¸")
            }
        }.start()

        // OS ì˜ˆì•½ (ìž ê¸ˆ/ì ˆì „ì—ì„œë„ ìš¸ë¦¬ë„ë¡)
        scheduleExactAlarm(triggerAt, "ë©”ì¸ íƒ€ì´ë¨¸")

        running = true
        btnStart.text = getString(R.string.btn_pause)
    }

    private fun pauseMain() {
        mainTimer?.cancel()
        cancelExactAlarm()
        running = false
        btnStart.text = getString(R.string.btn_start)
    }

    private fun resetMain() {
        mainTimer?.cancel()
        cancelExactAlarm()
        running = false
        timeLeftInMillis = 0L
        timerText.text = formatDuration4(0L)
        btnStart.text = getString(R.string.btn_start)
        nextTimeText.text = getString(R.string.next_time_prefix, formatDuration4(0L))
    }

    private fun updateMainTimerUI() {
        timerText.text = formatDuration4(timeLeftInMillis)
        nextTimeText.text = getString(R.string.next_time_prefix, formatDuration4(timeLeftInMillis))
    }

    /** -------- ê³µí†µ ìœ í‹¸ -------- */
    private fun updateNow() {
        val now = Calendar.getInstance()
        val h = now.get(Calendar.HOUR_OF_DAY)
        val m = now.get(Calendar.MINUTE)
        val s = now.get(Calendar.SECOND)
        val ms = now.get(Calendar.MILLISECOND) * 10
        currentTimeText.text = String.format(Locale.getDefault(), "%02d:%02d:%02d:%04d", h, m, s, ms)
    }

    private fun formatDuration4(msTotal: Long): String {
        val h = (msTotal / 3_600_000) % 100
        val m = (msTotal / 60_000) % 60
        val s = (msTotal / 1_000) % 60
        val ms4 = (msTotal % 1_000) * 10
        return String.format(Locale.getDefault(), "%02d:%02d:%02d:%04d", h, m, s, ms4)
    }

    private fun showRenameDialog(target: TextView, onRenamed: ((String) -> Unit)? = null) {
        val input = EditText(requireContext()).apply {
            inputType = InputType.TYPE_CLASS_TEXT
            setText(target.text?.toString() ?: "")
            setSelection(text.length)
        }
        AlertDialog.Builder(requireContext())
            .setTitle("ë¼ë²¨ ë³€ê²½")
            .setView(input)
            .setPositiveButton("í™•ì¸") { dlg, _ ->
                val txt = input.text?.toString()?.ifBlank { "íƒ€ì´ë¨¸" } ?: "íƒ€ì´ë¨¸"
                target.text = txt
                onRenamed?.invoke(txt)
                dlg.dismiss()
            }
            .setNegativeButton("ì·¨ì†Œ") { dlg, _ -> dlg.dismiss() }
            .show()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        mainTimer?.cancel()
        cancelExactAlarm()
        ticker?.let { handler.removeCallbacks(it) }
    }
}
