package com.krdonon.timer.alarm

import android.app.ActivityManager
import android.app.KeyguardManager
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.media.MediaPlayer
import android.os.Build
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.os.VibrationEffect
import android.os.Vibrator
import android.os.VibratorManager
import androidx.core.app.NotificationCompat
import com.krdonon.timer.R
import kotlin.math.abs
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

class AlarmService : Service() {

    companion object {
        // 채널
        private const val CHANNEL_ID = "ALARM_CHANNEL_V5"      // ★ IMPORTANCE_HIGH (풀스크린 동작용)
        private const val HISTORY_CHANNEL_ID = "ALARM_HISTORY_V1"

        // 포그라운드 알림 ID
        private const val NOTIFICATION_ID = 987654

        // 액션/엑스트라
        const val ACTION_START = "com.krdonon.timer.alarm.ACTION_START"
        const val ACTION_STOP  = "com.krdonon.timer.alarm.ACTION_STOP"
        const val EXTRA_LABEL  = "extra_label"

        // 상태 저장
        const val PREFS = "alarm_prefs"
        const val KEY_RINGING = "ringing"
        const val KEY_STARTED_FROM_KEYGUARD = "started_from_keyguard"

        // 알림 모드
        const val KEY_ALERT_MODE = "key_alert_mode"
        const val MODE_VIBRATE = "VIBRATE"   // 진동만
        const val MODE_SOUND   = "SOUND"     // 소리 + 진동 (기본)

        fun start(context: Context, label: String) {
            val i = Intent(context, AlarmService::class.java).apply {
                action = ACTION_START
                putExtra(EXTRA_LABEL, label)
            }
            try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    context.startForegroundService(i)
                } else {
                    context.startService(i)
                }
            } catch (_: Throwable) {
                forceStop(context)
            }
        }

        fun stop(context: Context) {
            val i = Intent(context, AlarmService::class.java).apply { action = ACTION_STOP }
            try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    if (isServiceRunning(context, AlarmService::class.java)) {
                        context.startService(i)
                    } else {
                        forceStop(context)
                    }
                } else {
                    context.startService(i)
                }
            } catch (_: Throwable) {
                forceStop(context)
            }
        }

        private fun isServiceRunning(ctx: Context, cls: Class<*>): Boolean {
            val am = ctx.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
            return am.getRunningServices(Int.MAX_VALUE).any { it.service.className == cls.name }
        }

        fun forceStop(context: Context) {
            runCatching { context.stopService(Intent(context, AlarmService::class.java)) }
            runCatching {
                val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                nm.cancel(NOTIFICATION_ID)
            }
            runCatching {
                context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
                    .edit().putBoolean(KEY_RINGING, false).apply()
            }
        }
    }

    private var mediaPlayer: MediaPlayer? = null
    private var vibrator: Vibrator? = null
    private val stopHandler = Handler(Looper.getMainLooper())

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_START -> {
                val label = intent.getStringExtra(EXTRA_LABEL) ?: "Timer Alarm"
                startAlarm(label)
            }
            ACTION_STOP -> stopAlarm()
        }
        return START_NOT_STICKY
    }

    override fun onBind(intent: Intent?): IBinder? = null

    // -------------------- 알람 시작/정지 --------------------
    private fun startAlarm(label: String) {
        val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        createOrUpdateAlarmChannel(nm)     // ★ IMPORTANCE_HIGH
        createOrUpdateHistoryChannel(nm)

        // 풀스크린 인텐트 (잠금화면 위로 Activity 표시)
        val fsIntent = Intent(this, AlarmActivity::class.java).apply {
            putExtra(EXTRA_LABEL, label)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_SINGLE_TOP)
        }
        val fsPi = PendingIntent.getActivity(
            this, 0, fsIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // 즉시 포그라운드(지연 방지)
        val n: Notification = NotificationCompat.Builder(this, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("⏰ 타이머 종료")
            .setContentText(label)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .setPriority(NotificationCompat.PRIORITY_MAX)
            .setCategory(NotificationCompat.CATEGORY_ALARM)
            .setOngoing(true)
            .setAutoCancel(false)
            .setFullScreenIntent(fsPi, true)     // ★ 핵심
            .build()
        startForeground(NOTIFICATION_ID, n)

        // 상태 플래그
        val km = getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager
        val startedFromKeyguard = km.isKeyguardLocked
        getSharedPreferences(PREFS, Context.MODE_PRIVATE).edit()
            .putBoolean(KEY_RINGING, true)
            .putBoolean(KEY_STARTED_FROM_KEYGUARD, startedFromKeyguard)
            .apply()

        // 모드 결정
        val prefs = getSharedPreferences(PREFS, Context.MODE_PRIVATE)
        val mode = prefs.getString(KEY_ALERT_MODE, MODE_SOUND) ?: MODE_SOUND

        stopHandler.removeCallbacksAndMessages(null)
        stopSound()
        startVibration()
        if (mode == MODE_SOUND) startSound()

        // 자동 종료(5분)
        stopHandler.postDelayed({ stopAlarm() }, 5 * 60 * 1000L)

        // 기록용 1회 알림(낮은 중요도)
        postHistoryNotification(label)
    }

    private fun stopAlarm() {
        stopHandler.removeCallbacksAndMessages(null)
        stopSound()
        stopVibration()

        getSharedPreferences(PREFS, Context.MODE_PRIVATE).edit()
            .putBoolean(KEY_RINGING, false)
            .apply()

        runCatching {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                stopForeground(STOP_FOREGROUND_REMOVE)
            } else {
                @Suppress("DEPRECATION")
                stopForeground(true)
            }
        }
        runCatching { stopSelf() }
    }

    override fun onDestroy() {
        stopSound(); stopVibration()
        super.onDestroy()
    }

    // -------------------- 소리 --------------------
    private fun startSound() {
        mediaPlayer = MediaPlayer.create(this, R.raw.alarm_sound)?.apply {
            isLooping = true
            setVolume(1.0f, 1.0f)
            start()
        }
    }
    private fun stopSound() {
        runCatching { mediaPlayer?.apply { if (isPlaying) stop() } }
        runCatching { mediaPlayer?.release() }
        mediaPlayer = null
    }

    // -------------------- 진동 --------------------
    private fun getVibrator(): Vibrator? {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val vm = getSystemService(VibratorManager::class.java)
            vm?.defaultVibrator
        } else {
            @Suppress("DEPRECATION")
            getSystemService(VIBRATOR_SERVICE) as Vibrator
        }
    }
    private fun startVibration() {
        vibrator = getVibrator()
        vibrator?.let { vib ->
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                vib.vibrate(VibrationEffect.createWaveform(longArrayOf(0, 500, 300), 0))
            } else {
                @Suppress("DEPRECATION")
                vib.vibrate(longArrayOf(0, 500, 300), 0)
            }
        }
    }
    private fun stopVibration() { runCatching { vibrator?.cancel() }; vibrator = null }

    // -------------------- 채널 & 기록 --------------------
    private fun createOrUpdateAlarmChannel(nm: NotificationManager) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val ch = NotificationChannel(
                CHANNEL_ID, "Timer Alarm", NotificationManager.IMPORTANCE_HIGH  // ★ HIGH
            ).apply {
                description = "타이머 알람 채널"
                lockscreenVisibility = Notification.VISIBILITY_PUBLIC
                setSound(null, null)   // 소리는 MediaPlayer로
                enableVibration(false) // 진동은 Vibrator로 (별도 제어)
            }
            nm.createNotificationChannel(ch)
        }
    }

    private fun createOrUpdateHistoryChannel(nm: NotificationManager) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val ch = NotificationChannel(
                HISTORY_CHANNEL_ID, "Alarm History", NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "알람 울림 기록"
                setSound(null, null)
                enableVibration(false)
            }
            nm.createNotificationChannel(ch)
        }
    }

    private fun postHistoryNotification(label: String) {
        val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        val time = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())
        val text = "$time • \"$label\" 알림이 울렸습니다"

        val n = NotificationCompat.Builder(this, HISTORY_CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("알림 기록")
            .setContentText(text)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setAutoCancel(true)
            .build()

        nm.notify(abs((System.currentTimeMillis() and 0xFFFFFFF).toInt()), n)
    }
}
